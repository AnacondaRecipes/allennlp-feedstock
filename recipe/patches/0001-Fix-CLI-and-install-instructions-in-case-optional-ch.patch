From d0a0dbcd626347c28c9875d21329a95a8484e440 Mon Sep 17 00:00:00 2001
From: "H. Vetinari" <h.vetinari@gmx.com>
Date: Tue, 22 Mar 2022 06:37:52 +1100
Subject: [PATCH] Fix CLI and install instructions in case optional checklists
 is not present (#5589)

* add conda instructions for optional checklist install

* clean up python 3.6 left-overs

* create dummy command if checklist not available

* do not import private submodules in util.import_module_and_submodules

* work-around for mypy issue

* also exclude test modules in import_module_and_submodules

* exclude some more modules

* shift type ignore

* run CI against base package

* add changelog

* Revert "run CI against base package"

This reverts commit 8713936886d4fb83a4da01895b2670473161d1e9.

* test CLI against package flavors

* fix typo in changelog

Co-authored-by: Akshita Bhagia <akshita23bhagia@gmail.com>
---
 .github/workflows/ci.yml                      |   5 +-
 README.md                                     |  14 +-
 allennlp/__init__.py                          |   7 -
 allennlp/commands/__init__.py                 |  12 +-
 allennlp/commands/_checklist_internal.py      | 204 +++++++++++++++++
 allennlp/commands/checklist.py                | 215 +++---------------
 allennlp/common/util.py                       |  18 +-
 .../task_checklists/__init__.py               |  29 +--
 .../task_checklists/task_suite.py             |   4 +-
 9 files changed, 273 insertions(+), 235 deletions(-)
 create mode 100644 allennlp/commands/_checklist_internal.py

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 64f26efa..808e80d8 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -348,6 +348,9 @@ jobs:
     strategy:
       matrix:
         python: ['3.7', '3.8', '3.9']
+        # check that CLI remains working for all package flavors;
+        # currently allennlp[checklist]==allennlp[all], so avoiding duplication on this
+        flavor: ['', '[all]']
 
     steps:
     - uses: actions/checkout@v2
@@ -369,7 +372,7 @@ jobs:
 
     - name: Install core package
       run: |
-        pip install $(ls dist/*.whl)[all]
+        pip install $(ls dist/*.whl)${{ matrix.flavor }}
 
     - name: Download NLTK prerequisites
       run: |
diff --git a/README.md b/README.md
index 174de2c1..489f0302 100644
--- a/README.md
+++ b/README.md
@@ -179,13 +179,19 @@ We support AllenNLP on Mac and Linux environments. We presently do not support W
 
 ### Installing via conda-forge
 
-The simplest way to install AllenNLP is using conda:
+The simplest way to install AllenNLP is using conda (you can choose a different python version):
 
 ```
 conda install -c conda-forge python=3.8 allennlp
 ```
 
-All plugins mentioned above are similarly installable, e.g.
+To install optional packages, such as `checklist`, use
+
+```
+conda install -c conda-forge allennlp-checklist
+```
+
+or simply install `allennlp-all` directly. The plugins mentioned above are similarly installable, e.g.
 
 ```
 conda install -c conda-forge allennlp-models allennlp-semparse allennlp-server allennlp-optuna
@@ -211,10 +217,10 @@ environment you want to use, you can skip to the 'installing via pip' section.
 
 1.  [Download and install Conda](https://conda.io/projects/conda/en/latest/user-guide/install/index.html).
 
-2.  Create a Conda environment with Python 3.7 (3.6 or 3.8 would work as well):
+2.  Create a Conda environment with Python 3.8 (3.7 or 3.9 would work as well):
 
     ```
-    conda create -n allennlp_env python=3.7
+    conda create -n allennlp_env python=3.8
     ```
 
 3.  Activate the Conda environment. You will need to activate the Conda environment in each terminal in which you want to use AllenNLP:
diff --git a/allennlp/__init__.py b/allennlp/__init__.py
index 8023569c..c66e897f 100644
--- a/allennlp/__init__.py
+++ b/allennlp/__init__.py
@@ -1,10 +1,3 @@
-# Make sure that allennlp is running on Python 3.6.1 or later
-# (to avoid running into this bug: https://bugs.python.org/issue29246)
-import sys
-
-if sys.version_info < (3, 6, 1):
-    raise RuntimeError("AllenNLP requires Python 3.6.1 or later")
-
 # We get a lot of these spurious warnings,
 # see https://github.com/ContinuumIO/anaconda-issues/issues/6678
 import warnings  # noqa
diff --git a/allennlp/commands/__init__.py b/allennlp/commands/__init__.py
index 15f64634..05ed2013 100644
--- a/allennlp/commands/__init__.py
+++ b/allennlp/commands/__init__.py
@@ -7,6 +7,7 @@ import warnings
 from allennlp import __version__
 from allennlp.commands.build_vocab import BuildVocab
 from allennlp.commands.cached_path import CachedPath
+from allennlp.commands.checklist import CheckList
 from allennlp.commands.diff import Diff
 from allennlp.commands.evaluate import Evaluate
 from allennlp.commands.find_learning_rate import FindLearningRate
@@ -22,17 +23,6 @@ from allennlp.common.util import import_module_and_submodules
 
 logger = logging.getLogger(__name__)
 
-try:
-    """
-    The `allennlp checklist` command requires installation of the optional dependency `checklist`.
-    It can be installed with `pip install allennlp[checklist]`.
-    """
-    with warnings.catch_warnings():
-        warnings.simplefilter("ignore")
-        from allennlp.commands.checklist import CheckList
-except ImportError:
-    pass
-
 
 class ArgumentParserWithDefaults(argparse.ArgumentParser):
     """
diff --git a/allennlp/commands/_checklist_internal.py b/allennlp/commands/_checklist_internal.py
new file mode 100644
index 00000000..bcf80691
--- /dev/null
+++ b/allennlp/commands/_checklist_internal.py
@@ -0,0 +1,204 @@
+"""
+The `checklist` subcommand allows you to conduct behavioural
+testing for your model's predictions using a trained model and its
+[`Predictor`](../predictors/predictor.md#predictor) wrapper.
+"""
+
+from typing import Optional, Dict, Any, List
+import argparse
+import sys
+import json
+import logging
+
+
+from allennlp.commands.subcommand import Subcommand
+from allennlp.common.checks import check_for_gpu, ConfigurationError
+from allennlp.models.archival import load_archive
+from allennlp.predictors.predictor import Predictor
+
+logger = logging.getLogger(__name__)
+
+try:
+    from allennlp.confidence_checks.task_checklists.task_suite import TaskSuite
+except ImportError:
+    raise
+
+
+@Subcommand.register("checklist")
+class CheckList(Subcommand):
+    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:
+
+        description = """Run the specified model through a checklist suite."""
+        subparser = parser.add_parser(
+            self.name,
+            description=description,
+            help="Run a trained model through a checklist suite.",
+        )
+
+        subparser.add_argument(
+            "archive_file", type=str, help="The archived model to make predictions with"
+        )
+
+        subparser.add_argument("task", type=str, help="The name of the task suite")
+
+        subparser.add_argument("--checklist-suite", type=str, help="The checklist suite path")
+
+        subparser.add_argument(
+            "--capabilities",
+            nargs="+",
+            default=[],
+            help=('An optional list of strings of capabilities. Eg. "[Vocabulary, Robustness]"'),
+        )
+
+        subparser.add_argument(
+            "--max-examples",
+            type=int,
+            default=None,
+            help="Maximum number of examples to check per test.",
+        )
+
+        subparser.add_argument(
+            "--task-suite-args",
+            type=str,
+            default="",
+            help=(
+                "An optional JSON structure used to provide additional parameters to the task suite"
+            ),
+        )
+
+        subparser.add_argument(
+            "--print-summary-args",
+            type=str,
+            default="",
+            help=(
+                "An optional JSON structure used to provide additional "
+                "parameters for printing test summary"
+            ),
+        )
+
+        subparser.add_argument("--output-file", type=str, help="Path to output file")
+
+        subparser.add_argument(
+            "--cuda-device", type=int, default=-1, help="ID of GPU to use (if any)"
+        )
+
+        subparser.add_argument(
+            "--predictor", type=str, help="Optionally specify a specific predictor to use"
+        )
+
+        subparser.add_argument(
+            "--predictor-args",
+            type=str,
+            default="",
+            help=(
+                "An optional JSON structure used to provide additional parameters to the predictor"
+            ),
+        )
+
+        subparser.set_defaults(func=_run_suite)
+
+        return subparser
+
+
+def _get_predictor(args: argparse.Namespace) -> Predictor:
+    check_for_gpu(args.cuda_device)
+    archive = load_archive(
+        args.archive_file,
+        cuda_device=args.cuda_device,
+    )
+
+    predictor_args = args.predictor_args.strip()
+    if len(predictor_args) <= 0:
+        predictor_args = {}
+    else:
+        predictor_args = json.loads(predictor_args)
+
+    return Predictor.from_archive(
+        archive,
+        args.predictor,
+        extra_args=predictor_args,
+    )
+
+
+def _get_task_suite(args: argparse.Namespace) -> TaskSuite:
+    available_tasks = TaskSuite.list_available()
+    if args.task in available_tasks:
+        suite_name = args.task
+    else:
+        raise ConfigurationError(
+            f"'{args.task}' is not a recognized task suite. "
+            f"Available tasks are: {available_tasks}."
+        )
+
+    file_path = args.checklist_suite
+
+    task_suite_args = args.task_suite_args.strip()
+    if len(task_suite_args) <= 0:
+        task_suite_args = {}
+    else:
+        task_suite_args = json.loads(task_suite_args)
+
+    return TaskSuite.constructor(
+        name=suite_name,
+        suite_file=file_path,
+        extra_args=task_suite_args,
+    )
+
+
+class _CheckListManager:
+    def __init__(
+        self,
+        task_suite: TaskSuite,
+        predictor: Predictor,
+        capabilities: Optional[List[str]] = None,
+        max_examples: Optional[int] = None,
+        output_file: Optional[str] = None,
+        print_summary_args: Optional[Dict[str, Any]] = None,
+    ) -> None:
+        self._task_suite = task_suite
+        self._predictor = predictor
+        self._capabilities = capabilities
+        self._max_examples = max_examples
+        self._output_file = None if output_file is None else open(output_file, "w")
+        self._print_summary_args = print_summary_args or {}
+
+        if capabilities:
+            self._print_summary_args["capabilities"] = capabilities
+
+    def run(self) -> None:
+        self._task_suite.run(
+            self._predictor, capabilities=self._capabilities, max_examples=self._max_examples
+        )
+
+        # We pass in an IO object.
+        output_file = self._output_file or sys.stdout
+        self._task_suite.summary(file=output_file, **self._print_summary_args)
+
+        # If `_output_file` was None, there would be nothing to close.
+        if self._output_file is not None:
+            self._output_file.close()
+
+
+def _run_suite(args: argparse.Namespace) -> None:
+
+    task_suite = _get_task_suite(args)
+    predictor = _get_predictor(args)
+
+    print_summary_args = args.print_summary_args.strip()
+    if len(print_summary_args) <= 0:
+        print_summary_args = {}
+    else:
+        print_summary_args = json.loads(print_summary_args)
+
+    capabilities = args.capabilities
+    max_examples = args.max_examples
+
+    manager = _CheckListManager(
+        task_suite,
+        predictor,
+        capabilities,
+        max_examples,
+        args.output_file,
+        print_summary_args,
+    )
+    manager.run()
diff --git a/allennlp/commands/checklist.py b/allennlp/commands/checklist.py
index bcf80691..99a8346b 100644
--- a/allennlp/commands/checklist.py
+++ b/allennlp/commands/checklist.py
@@ -2,203 +2,40 @@
 The `checklist` subcommand allows you to conduct behavioural
 testing for your model's predictions using a trained model and its
 [`Predictor`](../predictors/predictor.md#predictor) wrapper.
+
+It is based on the optional checklist package; if this is not
+available, the command will be replaced by a dummy.
 """
 
-from typing import Optional, Dict, Any, List
 import argparse
-import sys
-import json
 import logging
 
-
 from allennlp.commands.subcommand import Subcommand
-from allennlp.common.checks import check_for_gpu, ConfigurationError
-from allennlp.models.archival import load_archive
-from allennlp.predictors.predictor import Predictor
 
 logger = logging.getLogger(__name__)
 
 try:
-    from allennlp.confidence_checks.task_checklists.task_suite import TaskSuite
+    from allennlp.commands._checklist_internal import CheckList
 except ImportError:
-    raise
-
-
-@Subcommand.register("checklist")
-class CheckList(Subcommand):
-    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:
-
-        description = """Run the specified model through a checklist suite."""
-        subparser = parser.add_parser(
-            self.name,
-            description=description,
-            help="Run a trained model through a checklist suite.",
-        )
-
-        subparser.add_argument(
-            "archive_file", type=str, help="The archived model to make predictions with"
-        )
-
-        subparser.add_argument("task", type=str, help="The name of the task suite")
-
-        subparser.add_argument("--checklist-suite", type=str, help="The checklist suite path")
-
-        subparser.add_argument(
-            "--capabilities",
-            nargs="+",
-            default=[],
-            help=('An optional list of strings of capabilities. Eg. "[Vocabulary, Robustness]"'),
-        )
-
-        subparser.add_argument(
-            "--max-examples",
-            type=int,
-            default=None,
-            help="Maximum number of examples to check per test.",
-        )
-
-        subparser.add_argument(
-            "--task-suite-args",
-            type=str,
-            default="",
-            help=(
-                "An optional JSON structure used to provide additional parameters to the task suite"
-            ),
-        )
-
-        subparser.add_argument(
-            "--print-summary-args",
-            type=str,
-            default="",
-            help=(
-                "An optional JSON structure used to provide additional "
-                "parameters for printing test summary"
-            ),
-        )
-
-        subparser.add_argument("--output-file", type=str, help="Path to output file")
-
-        subparser.add_argument(
-            "--cuda-device", type=int, default=-1, help="ID of GPU to use (if any)"
-        )
-
-        subparser.add_argument(
-            "--predictor", type=str, help="Optionally specify a specific predictor to use"
-        )
-
-        subparser.add_argument(
-            "--predictor-args",
-            type=str,
-            default="",
-            help=(
-                "An optional JSON structure used to provide additional parameters to the predictor"
-            ),
-        )
-
-        subparser.set_defaults(func=_run_suite)
-
-        return subparser
-
-
-def _get_predictor(args: argparse.Namespace) -> Predictor:
-    check_for_gpu(args.cuda_device)
-    archive = load_archive(
-        args.archive_file,
-        cuda_device=args.cuda_device,
-    )
-
-    predictor_args = args.predictor_args.strip()
-    if len(predictor_args) <= 0:
-        predictor_args = {}
-    else:
-        predictor_args = json.loads(predictor_args)
-
-    return Predictor.from_archive(
-        archive,
-        args.predictor,
-        extra_args=predictor_args,
-    )
-
-
-def _get_task_suite(args: argparse.Namespace) -> TaskSuite:
-    available_tasks = TaskSuite.list_available()
-    if args.task in available_tasks:
-        suite_name = args.task
-    else:
-        raise ConfigurationError(
-            f"'{args.task}' is not a recognized task suite. "
-            f"Available tasks are: {available_tasks}."
-        )
-
-    file_path = args.checklist_suite
-
-    task_suite_args = args.task_suite_args.strip()
-    if len(task_suite_args) <= 0:
-        task_suite_args = {}
-    else:
-        task_suite_args = json.loads(task_suite_args)
-
-    return TaskSuite.constructor(
-        name=suite_name,
-        suite_file=file_path,
-        extra_args=task_suite_args,
-    )
-
-
-class _CheckListManager:
-    def __init__(
-        self,
-        task_suite: TaskSuite,
-        predictor: Predictor,
-        capabilities: Optional[List[str]] = None,
-        max_examples: Optional[int] = None,
-        output_file: Optional[str] = None,
-        print_summary_args: Optional[Dict[str, Any]] = None,
-    ) -> None:
-        self._task_suite = task_suite
-        self._predictor = predictor
-        self._capabilities = capabilities
-        self._max_examples = max_examples
-        self._output_file = None if output_file is None else open(output_file, "w")
-        self._print_summary_args = print_summary_args or {}
-
-        if capabilities:
-            self._print_summary_args["capabilities"] = capabilities
-
-    def run(self) -> None:
-        self._task_suite.run(
-            self._predictor, capabilities=self._capabilities, max_examples=self._max_examples
-        )
-
-        # We pass in an IO object.
-        output_file = self._output_file or sys.stdout
-        self._task_suite.summary(file=output_file, **self._print_summary_args)
-
-        # If `_output_file` was None, there would be nothing to close.
-        if self._output_file is not None:
-            self._output_file.close()
-
-
-def _run_suite(args: argparse.Namespace) -> None:
-
-    task_suite = _get_task_suite(args)
-    predictor = _get_predictor(args)
-
-    print_summary_args = args.print_summary_args.strip()
-    if len(print_summary_args) <= 0:
-        print_summary_args = {}
-    else:
-        print_summary_args = json.loads(print_summary_args)
-
-    capabilities = args.capabilities
-    max_examples = args.max_examples
-
-    manager = _CheckListManager(
-        task_suite,
-        predictor,
-        capabilities,
-        max_examples,
-        args.output_file,
-        print_summary_args,
-    )
-    manager.run()
+    # create dummy command that tells users how to
+    # install the necessary dependency
+
+    def _dummy_output(args: argparse.Namespace):
+        logger.info(
+            "The checklist integration of allennlp is optional; if you're using conda, "
+            "it can be installed with `conda install allennlp-checklist`, "
+            "otherwise use `pip install allennlp[checklist]`."
+        )
+
+    # need to work around https://github.com/python/mypy/issues/1153
+    @Subcommand.register("checklist")
+    class CheckList(Subcommand):  # type: ignore
+        def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:
+            description = """Dummy command because checklist is not installed."""
+            subparser = parser.add_parser(
+                self.name,
+                description=description,
+                help="Run a trained model through a checklist suite.",
+            )
+            subparser.set_defaults(func=_dummy_output)
+            return subparser
diff --git a/allennlp/common/util.py b/allennlp/common/util.py
index da54f162..8105db58 100644
--- a/allennlp/common/util.py
+++ b/allennlp/common/util.py
@@ -333,12 +333,20 @@ def push_python_path(path: PathType) -> ContextManagerFunctionReturnType[None]:
 
 def import_module_and_submodules(package_name: str, exclude: Optional[Set[str]] = None) -> None:
     """
-    Import all submodules under the given package.
+    Import all public submodules under the given package.
     Primarily useful so that people using AllenNLP as a library
     can specify their own custom packages and have their custom
     classes get loaded and registered.
     """
-    if exclude and package_name in exclude:
+    # take care of None
+    exclude = exclude if exclude else set()
+    try:
+        import checklist  # noqa
+    except ImportError:
+        # exclude modules that depends on checklist being present
+        exclude |= {"allennlp.confidence_checks.task_checklists"}
+
+    if package_name in exclude:
         return
 
     importlib.invalidate_caches()
@@ -358,6 +366,12 @@ def import_module_and_submodules(package_name: str, exclude: Optional[Set[str]]
             # `pkgutil.walk_packages` returns those too, so we need to skip them.
             if path_string and module_finder.path != path_string:  # type: ignore[union-attr]
                 continue
+            if name.startswith("_"):
+                # skip directly importing private subpackages
+                continue
+            if name.startswith("test"):
+                # as long as allennlp.common.testing is not under tests/, exclude it
+                continue
             subpackage = f"{package_name}.{name}"
             import_module_and_submodules(subpackage, exclude=exclude)
 
diff --git a/allennlp/confidence_checks/task_checklists/__init__.py b/allennlp/confidence_checks/task_checklists/__init__.py
index f6720cd6..33ed124a 100644
--- a/allennlp/confidence_checks/task_checklists/__init__.py
+++ b/allennlp/confidence_checks/task_checklists/__init__.py
@@ -1,19 +1,10 @@
-import warnings
-
-try:
-    from allennlp.confidence_checks.task_checklists.task_suite import TaskSuite
-    from allennlp.confidence_checks.task_checklists.sentiment_analysis_suite import (
-        SentimentAnalysisSuite,
-    )
-    from allennlp.confidence_checks.task_checklists.question_answering_suite import (
-        QuestionAnsweringSuite,
-    )
-    from allennlp.confidence_checks.task_checklists.textual_entailment_suite import (
-        TextualEntailmentSuite,
-    )
-except ImportError:
-    warnings.warn(
-        'To use the checklist integration you should install ``allennlp`` with the "checklist" '
-        "extra (e.g. ``pip install allennlp[checklist]``) or just install checklist after the fact."
-    )
-    raise
+from allennlp.confidence_checks.task_checklists.task_suite import TaskSuite
+from allennlp.confidence_checks.task_checklists.sentiment_analysis_suite import (
+    SentimentAnalysisSuite,
+)
+from allennlp.confidence_checks.task_checklists.question_answering_suite import (
+    QuestionAnsweringSuite,
+)
+from allennlp.confidence_checks.task_checklists.textual_entailment_suite import (
+    TextualEntailmentSuite,
+)
diff --git a/allennlp/confidence_checks/task_checklists/task_suite.py b/allennlp/confidence_checks/task_checklists/task_suite.py
index 9262f8c6..65b92c91 100644
--- a/allennlp/confidence_checks/task_checklists/task_suite.py
+++ b/allennlp/confidence_checks/task_checklists/task_suite.py
@@ -26,8 +26,8 @@ class TaskSuite(Registrable):
 
     !!! Note
         To use the checklist integration you should install ``allennlp`` with the
-        "checklist" extra (e.g. ``pip install allennlp[checklist]``) or just install
-        `checklist` after the fact.
+        "checklist" extra (e.g. ``conda install allennlp-checklist``,
+        ``pip install allennlp[checklist]`` or just install `checklist` after the fact).
 
     Task suites are intended to be used as a form of behavioral testing
     for NLP models to check for robustness across several general linguistic
-- 
2.35.1.windows.2

